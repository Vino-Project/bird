<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Flappy Bird Responsive</title>
  <link rel="icon" type="image/png" href="logo.png" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #70c5ce;
      overflow: hidden;
      height: 100%;
      touch-action: none;
    }
    canvas {
      display: block;
      margin: auto;
      background: linear-gradient(#70c5ce, #fff);
      border: 2px solid #333;
      border-radius: 6px;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// === Responsive canvas ===
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// === Bird object ===
const birdImg = new Image();
birdImg.src = 'bird-no.png'; // ganti dengan gambar burung kamu
let birdLoaded = false;
birdImg.onload = () => birdLoaded = true;

let bird = {
  x: canvas.width * 0.25,
  y: canvas.height / 2,
  size: Math.min(canvas.width, canvas.height) * 0.09, // lebih besar
  gravity: 0.5,
  lift: -8,
  velocity: 0
};

// === Pipes ===
let pipes = [];
let frame = 0;
let score = 0;
let highScore = localStorage.getItem("highScore") ? parseInt(localStorage.getItem("highScore")) : 0;
let gameOver = false;
let nextPipeDistance = 0;
let distanceSinceLastPipe = 0;

// === Control ===
function flap() {
  if (gameOver) {
    resetGame();
  } else {
    bird.velocity = bird.lift;
  }
}

window.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'Enter') flap();
});
canvas.addEventListener('click', flap);
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  flap();
}, {passive:false});

// === Spawn Pipes ===
let lastPipeY = canvas.height / 2; // posisi awal gap

function spawnPipe() {
  const baseGap = Math.max(canvas.height * 0.22, 140);
  const gap = baseGap - score * 0.2;

  // Tentukan batas perubahan vertikal antar pipa (maksimum perbedaan)
  const maxDelta = Math.max(canvas.height * 0.12, 80); // batas perbedaan antar gap
  const minY = 40;
  const maxY = canvas.height - gap - 100;

  // Posisi top baru = posisi sebelumnya Â± sedikit acak (tapi dibatasi)
  let newTop = lastPipeY + (Math.random() * maxDelta * 2 - maxDelta);

  // Pastikan tetap dalam batas layar
  newTop = Math.max(minY, Math.min(maxY, newTop));

  // Simpan posisi terakhir untuk pipa berikutnya
  lastPipeY = newTop;

  pipes.push({
    x: canvas.width,
    top: newTop,
    bottom: newTop + gap,
    width: Math.min(canvas.width, canvas.height) * 0.12,
    passed: false
  });
}


function setNextPipeDistance() {
  nextPipeDistance = canvas.width * (0.45 + Math.random() * 0.15);
}

// === Update Game Logic ===
function update() {
  if (gameOver) return;

  const W = canvas.width;
  const H = canvas.height;

  // Bird physics
  bird.velocity += bird.gravity;
  bird.y += bird.velocity;

  // Borders
  if (bird.y + bird.size > H) {
    bird.y = H - bird.size;
    gameOver = true;
    updateHighScore();
  }
  if (bird.y < 0) {
    bird.y = 0;
    bird.velocity = 0;
  }

  // Pipes movement
  let speed = 2.5 + Math.min(10, score / 10);
  pipes.forEach(p => p.x -= speed);
  distanceSinceLastPipe += speed;

  if (nextPipeDistance === 0) setNextPipeDistance();
  if (distanceSinceLastPipe >= nextPipeDistance) {
    spawnPipe();
    distanceSinceLastPipe = 0;
    setNextPipeDistance();
  }

  // Remove offscreen pipes
  pipes = pipes.filter(p => p.x + p.width > -50);

  // Collision detection
  pipes.forEach(p => {
    const bx = bird.x + bird.size * 0.1;
    const by = bird.y + bird.size * 0.1;
    const bw = bird.size * 0.8;
    const bh = bird.size * 0.8;

    if (
      bx < p.x + p.width &&
      bx + bw > p.x &&
      (by < p.top || by + bh > p.bottom)
    ) {
      gameOver = true;
      updateHighScore();
    }

    if (!p.passed && p.x + p.width < bird.x) {
      score++;
      p.passed = true;
    }
  });
}

// === Update High Score ===
function updateHighScore() {
  if (score > highScore) {
    highScore = score;
    localStorage.setItem("highScore", highScore);
  }
}

// === Render ===
function render() {
  const W = canvas.width;
  const H = canvas.height;

  ctx.clearRect(0, 0, W, H);

  // Background
  ctx.fillStyle = '#70c5ce';
  ctx.fillRect(0, 0, W, H);

  // Pipes
  ctx.fillStyle = '#228B22';
  pipes.forEach(p => {
    ctx.fillRect(p.x, 0, p.width, p.top);
    ctx.fillRect(p.x, p.bottom, p.width, H - p.bottom);
  });

  // Bird
  if (birdLoaded) {
    ctx.drawImage(birdImg, bird.x, bird.y, bird.size, bird.size);
  } else {
    ctx.fillStyle = 'yellow';
    ctx.beginPath();
    ctx.arc(bird.x + bird.size / 2, bird.y + bird.size / 2, bird.size / 2, 0, Math.PI * 2);
    ctx.fill();
  }

  // Score
  ctx.fillStyle = 'white';
  ctx.font = `${Math.min(W, H) * 0.05}px Arial Black`;
  ctx.textAlign = 'left';
  ctx.fillText(`Score: ${score}`, 20, 50);
  ctx.fillText(`Best: ${highScore}`, 20, 100);

  // Game Over Overlay
  if (gameOver) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, W, H);

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'yellow';
    ctx.font = `${Math.min(W, H) * 0.08}px Arial Black`;
    ctx.fillText('GAME OVER', W / 2, H / 2 - H * 0.05);

    ctx.font = `${Math.min(W, H) * 0.04}px Arial`;
    ctx.fillText(`Score: ${score}   |   Best: ${highScore}`, W / 2, H / 2 + H * 0.03);
    ctx.fillText('Tap / Space / Enter to Restart', W / 2, H / 2 + H * 0.1);
  }
}

// === Reset ===
function resetGame() {
  bird.x = canvas.width * 0.25;
  bird.y = canvas.height / 2;
  bird.size = Math.min(canvas.width, canvas.height) * 0.09;
  bird.velocity = 0;
  pipes = [];
  score = 0;
  gameOver = false;
  nextPipeDistance = 0;
  distanceSinceLastPipe = canvas.width * 0.15;
  spawnPipe();
  setNextPipeDistance();
}

// === Game Loop ===
function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

// Start
resetGame();
gameLoop();
</script>
</body>
</html>
